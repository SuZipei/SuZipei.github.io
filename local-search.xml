<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>另一元宵节 线段树</title>
    <link href="/2020/03/08/hzoi0002/"/>
    <url>/2020/03/08/hzoi0002/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/hzoi0002.png"></p><p>其实最开始这个题我没做出来是因为我不知道&amp;是啥意思，我以为是加和</p><span id="more"></span><p>这个题的意思其实就是让构建一个数组，使它的某个区间按位与的和为一个数，看看会不会产生矛盾。</p><p>知道这一点后就好办了，新建一个为0的数组，每次查询就 | 一下，然后查询区间按位与的和，看看符不符合]</p><p>为什么要 | 呢？</p><p>这要考虑&amp;是怎么运算的了</p><p>在二进制位下，只有两个数字的某一位上都是1，&amp;出来才是1，所以也有一个很显然的问题，&amp;出来的数不一定与区间内的每一个数相等</p><p>但他们的二进制位下，&amp;出来的数的二进制位一定相等，所以每次查询的时候把要查询的那个数对应的二进制位 | 一下就行了</p><p>然后就是线段树的板子吧，这里不能用树状数组，想想为什么</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll tree[N],lazy[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updata</span><span class="hljs-params">(<span class="hljs-type">int</span> rt,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,ll w)</span></span>&#123;<br>    tree[rt]=tree[rt]|w;<br>    lazy[rt]=tree[rt]|w;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> rt,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">updata</span>(rt&lt;&lt;<span class="hljs-number">1</span>,l,mid,lazy[rt]);<br>    <span class="hljs-built_in">updata</span>(rt&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,lazy[rt]);<br>    lazy[rt]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> rt,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> t,ll w)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s&lt;=l&amp;&amp;r&lt;=t)&#123;<br>        <span class="hljs-built_in">updata</span>(rt,l,r,w);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">pushdown</span>(rt,l,r);<br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(s&lt;=mid)<span class="hljs-built_in">modify</span>(rt&lt;&lt;<span class="hljs-number">1</span>,l,mid,s,t,w);<br>    <span class="hljs-keyword">if</span>(t&gt;mid)<span class="hljs-built_in">modify</span>(rt&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,s,t,w);<br>    tree[rt]=tree[rt&lt;&lt;<span class="hljs-number">1</span>]&amp;tree[rt&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> rt,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> t)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s&lt;=l&amp;&amp;t&gt;=r)<span class="hljs-keyword">return</span> tree[rt];<br>    <span class="hljs-built_in">pushdown</span>(rt,l,r);<br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(t&lt;=mid)<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rt&lt;&lt;<span class="hljs-number">1</span>,l,mid,s,t);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s&gt;mid)<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rt&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,s,t);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rt&lt;&lt;<span class="hljs-number">1</span>,l,mid,s,t)&amp;<span class="hljs-built_in">query</span>(rt&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,s,t);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> m,n,t;<span class="hljs-type">bool</span> flag;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;kuai.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;kuai.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>        flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">memset</span>(tree,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(tree));<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-type">int</span> l,r;<br>            ll w;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%lld&quot;</span>,&amp;l,&amp;r,&amp;w);<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,l,r,w);<br>            ll data=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,l,r);<br>            <span class="hljs-keyword">if</span>(data!=w)flag=<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>早期水题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOI ONLINE 提高组 序列</title>
    <link href="/2020/03/08/noionline/"/>
    <url>/2020/03/08/noionline/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><span id="more"></span><p>小 D 有一个长度为 $n$ 的整数序列 $a_{1 \dots n}$，她想通过若干次操作把它变成序列 $b_i$。</p><p>小 D 有 $m$ 种可选的操作，第 $i$ 种操作可使用三元组 $(t_i,u_i,v_i)$ 描述：若 $t_i=1$，则她可以使 $a_{u_i}$ 与 $a_{v_i}$ 都加一或都减一；若 $t_i=2$，则她可以使 $a_{u_i}$ 减一、$a_{v_i}$ 加一，或是 $a_{u_i}$ 加一、$a_{v_i}$ 减一，因此当 $u_i=v_i$ 时，这种操作相当于没有操作。</p><p>小 D 可以以任意顺序执行操作，且每种操作都可进行无限次。现在给定序列与所有操作，请你帮她判断是否存在一种方案能将 $a_i$ 变为 $b_i$。题目保证两个序列长度都为 $n$。若方案存在请输出 <code>YES</code>，否则输出 <code>NO</code>。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>本题输入文件包含多组数据。</p><p>第一行一个正整数 $T$ 表示数据组数。对于每组数据：</p><p>第一行两个整数 $n,m$，表示序列长度与操作种数。</p><p>第二行 $n$ 个整数表示序列 $a_i$。</p><p>第三行 $n$ 个整数表示序列 $b_i$。</p><p>接下来 $m$ 行每行三个整数 $t_i,u_i,v_i$，第 $i$ 行描述操作 $i$。</p><p>注意：同一个三元组 $(t_i,u_i,v_i)$ 可能在输入中出现多次。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>对于每组数据输出一行一个字符串 <code>YES</code> 或 <code>NO</code> 表示答案。</p><h1 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h1><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h1 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h1><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">YES</span><br><span class="hljs-keyword">YES</span><br><span class="hljs-keyword">YES</span><br></code></pre></td></tr></table></figure><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><p>第一组数据：使用一次操作 $1$。<br>第二组数据：使用三次操作 $1$。<br>第三组数据：使用三次操作 $1$，令 $a_1,a_2$ 都增加 $3$，再使用一次操作 $2$，令 $a_1,a_3$ 都增加 $1$。</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>对于测试点 $1 \sim 5$：$n=2$，$m=1$，$a_i,b_i \le 99$，$u_1 \ne v_1$，$t_1=1$。<br>对于测试点 $6 \sim 10$：$n=2$，$m=1$，$a_i,b_i \le 99$，$u_1 \ne v_1$，$t_1=2$。<br>对于测试点 $11 \sim 12$：$n=2$，$a_i,b_i \le 99$，$u_i \ne v_i$。<br>对于测试点 $13 \sim 16$：$t_i=2$。<br>对于测试点 $17$：$n,m \le 20$。<br>对于测试点 $18$：$n,m \le 10^3$。<br>对于所有测试点：$1 \le T \le 10$，$1 \le n,m \le 10^5$，$1 \le a_i,b_i \le 10^9$，$t_i \in {1,2}$，$1\le u_i,v_i \le n$。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>说实话第一眼看到这题的时候我有点懵，真不知道怎么做，不过一看数据，还好还好，暴力能拿一半分，于是我就真拿了一半分。。。。。</p><p>但某大佬说暴力能拿60，但我拿一半就满意了   我不会啊</p><p>考完后忍不住好奇这道题要怎么做，于是就看了看题解，发现题解也。。。有点难懂，主要是我看到一个字，图？？这明明是个数的问题咋还和图扯上了关系，awsl，果然还是我太菜了</p><p>仔细读了一下，明白了一些。先看操作一：如果有(a1,a2)(a2,a3)(a3,a1),那么其中任意一个数都能自己加减二，如a1，a1+1,a2+1,a2-1,a3-1,a3+1,a1+1这样就能让a1自己加减二，同理a1换成任何数都可以，这里要注意，必须是奇数个点并且形成环才能这样办，所以每个奇数环上的数都能加减二，偶数个点为什么不行自己举个例子就明白了。再看操作二：如果有(a1,a2)(a2,a3)那么可以知道(a1,a3)，a1+1,a2-1,a2+1,a3-1由此,a1+1，a3-1，可见操作二是具有传递性的，如果把它们看做是一个联通块，那么这个联通块可以任意加1，减1，所以如果这个联通块需要加的值和需要减的值一样，那么就满足。于是我们只要把每个操作二都缩成点，每个操作一建边，然后开始判断每块联通块是不是满足题意。</p><p>判断方法为，如果未形成奇数环，则需要使联通块内相加的数与相减的数相等，因为只能加一减一，否则使需要变化的总数是偶数即可，注意自环也要判断，因为自环相当于(a1,a2,1)(a1,a2,2)即a1+1,a2+1,a2-1,a1+1,这样也能使任意数加减二，</p><p>然后还有就是对于没有边连入的点，只有需要变化的值为0，才满足，因为没有边可以使它产生变化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> val[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> to,next;<br>&#125;e[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> t,u,v;<br>&#125;p[N];<br><span class="hljs-type">int</span> Head[N],len,sum,flag;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Ins</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[++len].to=b;e[len].next=Head[a];Head[a]=len;<br>&#125;<br><span class="hljs-type">int</span> f[N],belong[N],a[N],b[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> f[x]==x?x:(f[x]=<span class="hljs-built_in">find</span>(f[x]));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Mer</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-type">int</span> u=<span class="hljs-built_in">find</span>(a),v=<span class="hljs-built_in">find</span>(b);<br>    <span class="hljs-keyword">if</span>(u!=v)&#123;<br>        f[u]=v;val[v]+=val[u];<span class="hljs-comment">//并查集缩点</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> bin)</span></span>&#123;<br>    belong[x]=bin;<br>    <span class="hljs-keyword">if</span>(bin)sum+=val[x];<br>    <span class="hljs-keyword">else</span> sum-=val[x];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=Head[x];i;i=e[i].next)&#123;<br>        <span class="hljs-type">int</span> v=e[i].to;<br>        <span class="hljs-keyword">if</span>(belong[v]==<span class="hljs-number">-1</span>)<span class="hljs-built_in">dfs</span>(v,bin^<span class="hljs-number">1</span>);<span class="hljs-comment">//利用了^的性质</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(belong[x]==belong[v])<span class="hljs-comment">//说明v已经被提前访问过并且bin的值与x一样，那么就一定形成了奇数环</span><br>            flag=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//    freopen(&quot;a.txt&quot;,&quot;r&quot;,stdin);</span><br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>        <span class="hljs-type">int</span> m,n,ans=<span class="hljs-number">1</span>;len=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;b[i]),val[i]=b[i]-a[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            f[i]=i,belong[i]=<span class="hljs-number">-1</span>,Head[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;p[i].t,&amp;p[i].u,&amp;p[i].v);<br>            <span class="hljs-keyword">if</span>(p[i].t==<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-built_in">Mer</span>(p[i].u,p[i].v);<span class="hljs-comment">//合并操作二</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-keyword">if</span>(p[i].t==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-built_in">Ins</span>(<span class="hljs-built_in">find</span>(p[i].u),<span class="hljs-built_in">find</span>(p[i].v));<span class="hljs-comment">//这里已经缩点所以要合并根</span><br>                <span class="hljs-built_in">Ins</span>(<span class="hljs-built_in">find</span>(p[i].v),<span class="hljs-built_in">find</span>(p[i].u));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i)==i&amp;&amp;belong[i]==<span class="hljs-number">-1</span>)&#123;<br>                flag=sum=<span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=Head[i];x;x=e[x].next)&#123;<br>                    <span class="hljs-keyword">if</span>(e[x].to==i)flag=<span class="hljs-number">1</span>;<span class="hljs-comment">//自环</span><br>                &#125;<br>                <span class="hljs-keyword">if</span>(Head[i]==<span class="hljs-number">0</span>&amp;&amp;sum!=<span class="hljs-number">0</span>)ans=<span class="hljs-number">0</span>;<span class="hljs-comment">//没有边连入</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>&amp;&amp;sum%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)ans=<span class="hljs-number">0</span>;<span class="hljs-comment">//奇数环</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>&amp;&amp;sum!=<span class="hljs-number">0</span>)ans=<span class="hljs-number">0</span>;<span class="hljs-comment">//偶数环</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ans)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>思维题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 1062 昂贵的聘礼</title>
    <link href="/2020/03/07/poj1062/"/>
    <url>/2020/03/07/poj1062/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>年轻的探险家来到了一个印第安部落里。在那里他和酋长的女儿相爱了，于是便向酋长去求亲。</p><span id="more"></span><p>酋长要他用10000个金币作为聘礼才答应把女儿嫁给他。探险家拿不出这么多金币，便请求酋长降低要求。酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要8000金币。如果你能够弄来他的水晶球，那么只要5000金币就行了。”探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。另外他要告诉你的是，在这个部落里，等级观念十分森严。地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。他是一个外来人，所以可以不受这些限制。但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。因此你需要在考虑所有的情况以后给他提供一个最好的方案。 <br>为了方便起见，我们把所有的物品从1开始进行编号，酋长的允诺也看作一个物品，并且编号总是1。每个物品都有对应的价格P，主人的地位等级L，以及一系列的替代品Ti和该替代品所对应的”优惠”Vi。如果两人地位等级差距超过了M，就不能”间接交易”。你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。 </p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>输入第一行是两个整数M，N（1 &lt;= N &lt;= 100），依次表示地位等级差距限制和物品的总数。接下来按照编号从小到大依次给出了N个物品的描述。每个物品的描述开头是三个非负整数P、L、X（X &lt; N），依次表示该物品的价格、主人的地位等级和替代品总数。接下来X行每行包括两个整数T和V，分别表示替代品的编号和”优惠价格”。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出最少需要的金币数。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">10000 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">8000</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5000</span><br><span class="hljs-symbol">1000 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">200</span><br><span class="hljs-symbol">3000 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">200</span><br><span class="hljs-symbol">50 </span><span class="hljs-number">2</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">5250</span><br></code></pre></td></tr></table></figure><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>输出最小的金币数，这道题首先想到的就是建图跑最小路，我最开始用的方法是根据所给信息把边权和点权都加上，然后在跑Dij的时候判断</p><p>如果选择边权，那么还要加和这个点的儿子的权，如果选择点权就不用，然后统计到各个点最小距离。</p><p>打了一下样例没过，然后回去想，发现加的是双向边，于是又加了一个vis数组判断是否访问过，这次样例过了，交上去WA</p><p>再仔细想一下，先不管我的点权和边权处理有没有问题，就一个问题是很难解决的，就是终点是什么，不一定所有的点都能当做本次统计的终点</p><p>也就是说它会直接返回最小值，不管这个最小值是不是已经把所有需要的点权边权都包括进去了，比如我要买二号物品来降低一号物品价格，在统计</p><p>到二号物品的路程时，直接返回了边权，但点权也是应该加上的，所以没有选完全，我感觉还是我的程序有问题　</p><p>重新思考，有没有一种方法能够让程序自动判断选择边权还是点权，并且终点是一样的？</p><p>受如果使用该物品的话边权和点权必选其一的启发，我们可以采用超级源点，即把所有的点的点权作为这个点和超级源点的边权，于是又跑一遍</p><p>又没过样例，这次我发现一个问题，我加的是双向边，而加双向边是肯定不行的，因为边权表示买二号物品得到三号物品的优惠，如果加双向的话就</p><p>表明买三号物品也能得到二号物品的优惠，这显然是不对的，于是我们考虑边的方向，从源点出来，边的去向一定是指向每个点，因为我们是以源点</p><p>为起点，一号物品为终点跑的Dij，所以输入时，如果买a对b有优惠，那么Add_Edge(a-&gt;b)，这样就可以保证终点是一样的，且最短路径上每个点的</p><p>点权或边权都被选完全了。</p><p>修改完代码，测了测样例，对了！然后交上去，WA。。。。</p><p>接着我思考半天后找到了我最开始过深考虑的问题——等级，我起初是怎么处理的呢？我在建图时判断，如果一个点的等级与第一物品的差值的</p><p>绝对值小于m，就不加这个点及其周围的边。这么看好像是对的，举个例子，m=3，level[1]=8,我们买了level[2]=6,level[3]=10的两个物品，由题意，</p><p>这不被允许，所以不能这么判断，但这给了我一个启发：买的物品价值范围（levelmax-levelmin&lt;=m）,所以我们可以考虑枚举物品的价值范围，每次</p><p>对于枚举的范围进行Dij求最短路，输出最短的路径即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">110</span>,INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> to,next,val;<br>&#125;e[N*N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> id,val;<br>    <span class="hljs-built_in">Node</span>()&#123;&#125;;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;id=a;val=b;&#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Node&amp;A)<span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> val&gt;A.val;<br>    &#125;<br>&#125;;<br><span class="hljs-type">int</span> Head[N],len,lev[N],ans,m,n,dis[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Ins</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    e[++len].to=b;e[len].val=c;<br>    e[len].next=Head[a];Head[a]=len;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span></span>&#123;<br>    priority_queue&lt;Node&gt; q;<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>    dis[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Node</span>(<span class="hljs-number">0</span>,dis[<span class="hljs-number">0</span>]));<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        Node u=q.<span class="hljs-built_in">top</span>();q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=Head[u.id];x;x=e[x].next)&#123;<br>            <span class="hljs-type">int</span> v=e[x].to;<br>            <span class="hljs-keyword">if</span>(lev[v]-level&gt;m||lev[v]&lt;level)<span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(dis[v]&gt;dis[u.id]+e[x].val)&#123;<br>                dis[v]=dis[u.id]+e[x].val;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Node</span>(v,dis[v]));<br>            &#125;<br>        &#125;<br>    &#125;<br>    ans=<span class="hljs-built_in">min</span>(ans,dis[<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// freopen(&quot;a.txt&quot;,&quot;r&quot;,stdin);</span><br>    <span class="hljs-type">int</span> selfval;<br>    ans=INF;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;selfval,&amp;lev[i],&amp;c);<br>        <span class="hljs-built_in">Ins</span>(<span class="hljs-number">0</span>,i,selfval);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=c;j++)&#123;<br>            <span class="hljs-type">int</span> a,b;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<br>            <span class="hljs-built_in">Ins</span>(a,i,b);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lev[<span class="hljs-number">1</span>]-m;i&lt;=lev[<span class="hljs-number">1</span>];i++)<br>        <span class="hljs-built_in">dij</span>(i);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> </p><p>这个问题看起来还是比较难的，但是想明白以后也比较简单，下次在做题的时候一定把问题先想清楚，边做边想太难了。。。。。。</p><p> </p>]]></content>
    
    
    <categories>
      
      <category>早期水题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>某年元宵节大礼包</title>
    <link href="/2020/03/07/hzoi0001/"/>
    <url>/2020/03/07/hzoi0001/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>乐是做作业，给定正整数 N,M，要求计算Concatenate（1……N）mod M的值，其中Concatenate是指将1到N拼起来得到的数。如N=13，Concatenate=12345678910111213</p><span id="more"></span><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>一行两个整数，N，M</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>一个非负整数表示计算结果</p><h1 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h1><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">13 </span><span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>$n \leq 10^{18},m\leq 10^9$ </p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>第一眼看到这题：暴力模拟</p><p>然后看到数据表示无语，1e18啊，这拼起来得多大</p><p>不管了先弄一个模拟：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> s;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wei</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (x) &#123;<br>        s++;<br>        x /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;le.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;le.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        s = (s * <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-built_in">wei</span>(i)) + i),<br>        s = s % m;<br>    cout &lt;&lt; s;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个应该很好懂，就不解释了，30分</p><p>作为一个合格的OI选手，一定是要考虑正解的。</p><p>设ans[i]表示拼接到i位时的答案，我们很容易得到递推式：</p><p>ans[i]=(ans[i-1]*p+i)%mod; </p><p>其中p表示当前i的位数乘十，先不考虑mod，比如ans[4]=123*10+4；</p><p>于是这又是一个递推式问题，那么怎么办呢？暴力跑一遍?1e18的数据不TLE算我输</p><p>所以这个时候矩阵快速幂来了……</p><p>可以设一个矩阵A为</p><p>{ans[i]  i  1} 反正我是习惯开一维数组。。。。</p><p>然后另一个矩阵K为</p><p>{p　0　0}</p><p>{1　1　0}</p><p>{1　1　1}</p><p>这样A*K就能得到{ans[i]*p+i  i+1  1}即{ans[i+1]  i+1  1}</p><p>是不是很巧妙，所以不难看出上述A中的1的作用——与ans[i],凑出ans[i+1]和i+1.</p><p>接着考虑乘多少次方的问题，我们从i=0开始，如果n=4，那么显然要乘四次；</p><p>如果n=14呢？从0到9，一共要乘9次，然后再从10到14乘5次</p><p>接着多次进行迭代不难发现，我们可以用变量data拷贝n</p><p>如果n&gt;=p就乘9*p/10次，data减去乘的值</p><p>当n &lt; p 时说明不够乘了，所以直接乘以data次</p><p>最后跑快速幂就行了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br>ull n,mod,a[<span class="hljs-number">4</span>],c[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Mul</span><span class="hljs-params">()</span></span>&#123;<br>    ull cp[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">memset</span>(cp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(cp));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">3</span>;j++)&#123;<br>            cp[i]+=((a[j]%mod)*(c[j][i]%mod))%mod;<br>            <span class="hljs-comment">//乘之前一定要mod一下不然两个数乘积可能超出longlong</span><br>            cp[i]%=mod;<br>        &#125;  <br>    &#125;<br>    <span class="hljs-built_in">memcpy</span>(a,cp,<span class="hljs-built_in">sizeof</span>(cp));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Mulself</span><span class="hljs-params">()</span></span>&#123;<br>    ull cp[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">memset</span>(cp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(cp));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">3</span>;j++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">3</span>;k++)&#123;<br>                cp[i][j]+=((c[i][k]%mod)*(c[k][j]%mod))%mod;<br>                cp[i][j]%=mod;<br>            &#125;<br>    <span class="hljs-built_in">memcpy</span>(c,cp,<span class="hljs-built_in">sizeof</span>(cp));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%llu%llu&quot;</span>,&amp;n,&amp;mod);<br>    a[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;a[<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;a[<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;<br>    ull mx=n*<span class="hljs-number">10</span>,data=n;<br>    <span class="hljs-keyword">for</span>(ull p=<span class="hljs-number">10LL</span>;p&lt;=mx;p*=<span class="hljs-number">10LL</span>)&#123;<br>        c[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=p;c[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;c[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">0</span>;<br>        c[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;c[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;c[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">0</span>;<br>        c[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;c[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;c[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;<br>        ull x;<br>        <span class="hljs-keyword">if</span>(n&gt;=p)&#123;<br>            x=<span class="hljs-number">9LL</span>*p/<span class="hljs-number">10LL</span>;<br>            data-=x;<br>        &#125;<br>        <span class="hljs-keyword">else</span> x=data;<br>        <span class="hljs-keyword">while</span>(x)&#123;<br>            <span class="hljs-keyword">if</span>(x&amp;<span class="hljs-number">1</span>)<span class="hljs-built_in">Mul</span>();<br>            x&gt;&gt;=<span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">Mulself</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%llu\n&quot;</span>,a[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>早期水题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>矩阵快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 3303 Harmony Forever</title>
    <link href="/2020/03/07/HDU3303/"/>
    <url>/2020/03/07/HDU3303/</url>
    
    <content type="html"><![CDATA[<h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>We believe that every inhabitant of this universe eventually will find a way to live together in harmony and peace; that trust, patience, kindness and loyalty will exist between every living being of this earth; people will find a way to appreciate and cooperate with each other instead of continuous bickering, arguing and fighting. Harmony – the stage of society so many people dream of and yet it seems so far away from now …</p><span id="more"></span><p>Fortunately, the method of unlocking the key to true Harmony is just discovered by a group of philosophers. It is recorded on a strange meteorite which has just hit the earth. You need to decipher the true meaning behind those seemingly random symbols … More precisely, you are to write a program which will support the following two kinds of operation on an initially empty set S :</p><ol><li>B X : Add number X to set S . The Kth command in the form of B X always happens at time K , and number X does not belong to set S before this operation.</li><li>A Y : Of all the numbers in set S currently, find the one which has the minimum remainder when divided by Y . In case a tie occurs, you should choose the one which appeared latest in the input. Report the time when this element is inserted.<br>It is said that if the answer can be given in the minimum possible time, true Harmony can be achieved by human races. You task is to write a program to help us.</li></ol><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>There are multiple test cases in the input file. Each test case starts with one integer T where 1&lt;=T&lt;=40000 . The following T lines each describe an operation, either in the form of “B X “ or “A Y “ where 1&lt;=X , Y&lt;=500000 .</p><p>T = 0 indicates the end of input file and should not be processed by your program.</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>Print the result of each test case in the format as indicated in the sample output. For every line in the form of “A Y “, you should output one number, the requested number, on a new line; output -1 if no such number can be found. Separate the results of two successive inputs with one single blank line.</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">5</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">A</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">10</span><br><span class="hljs-attribute">A</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">A</span> <span class="hljs-number">40</span><br><span class="hljs-attribute">2</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">A</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">0</span><br></code></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Case</span> <span class="hljs-number">1</span>:<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br><span class="hljs-keyword">Case</span> <span class="hljs-number">2</span>:<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p><del>让你拯救世界</del></p><p>给定一空集合，有两种操作，往集合里加数或者求出集合中的数在mod k意义下最小值是第几个加入的，相等的话输出最后加入的</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>不管怎么样先想一个暴力吧，单开一个数组记录往里边加的数，下边i表示加入时间，每次查询遍历一遍数组就行　</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> ss[<span class="hljs-number">5</span>];<br>    <span class="hljs-type">int</span> num,t,cas=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t))&#123;<br>        <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(cas)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %d:\n&quot;</span>,++cas);<br>        <span class="hljs-keyword">while</span>(t--)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d&quot;</span>,ss,&amp;num);<br>            <span class="hljs-keyword">if</span>(ss[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;B&#x27;</span>)<br>                a[++len]=num;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">bool</span> flag=<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> Min=num,ans;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>                    <span class="hljs-keyword">if</span>(a[i]%num&lt;=Min)&#123;<br>                        flag=<span class="hljs-number">0</span>;<br>                        Min=a[i]%num;<br>                        ans=i;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(flag)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>                <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>抱着试一试的心态交了上去，A了！！！没错它A了，但显然这不是正解，只是HDU数据水了，我自己手造了一组极限数据就跑了2s多，然后我又把它交到了POJ上，果然是TLE。</p><p>那肯定是要优化咯，怎么优化呢？涉及到mod的问题，如果要mod k在连续长度大于k的区间中，mod k一定会至少有两个数相等，所以我们可以考虑将50w分块，分为0-k-1，k-2k-1…………这样遍历每一块，每一块中最小的数mod k就有可能是答案，于是这个问题就成了，在区间内找到最小的已经出现过的数字，涉及到区间问题，很容易想到线段树和树状数组，但这个问题好像没有必要用线段树，树状数组足以。</p><p>开一棵50w的树状数组，每一个点记录到这个点一共出现了多少数字，接着就是找最小的已经出现过的数，那么不就又是暴力了吗？查找的方法除了暴力就只会二分，于是我们考虑二分查找，怎么二分呢？每次查找区间的时候，对该区间进行二分就行了，那你怎么知道是要向左分还是向右分？用树状数组很容易求得到区间左端点的点总数，取mid，如果到mid的点总数和到左端的点总数相等，说明l到mid之间没有数，改变左端点，如果有就改变右端点，更新最小值，继续二分直到l==r，树状数组的做法就是这样，线段树也大致差不多。</p><p>还有一个问题，如果k过小了，比如k就是1，那么我们就会将区间分成50w块，50w啊！而暴力最多只枚举4w，所以我们可以设置一个值，让k过大的时候直接用暴力。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> limit=<span class="hljs-number">1317</span>;<span class="hljs-comment">//这个数还可以换，让它别太小就行</span><br>                     <span class="hljs-comment">//不要问我为什么非用这个奇怪的数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> q[N+<span class="hljs-number">5</span>],tim[N+<span class="hljs-number">5</span>],a[N+<span class="hljs-number">5</span>],len,c[N+<span class="hljs-number">5</span>];<span class="hljs-comment">//多开5，防止RE</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> i&amp;(-i);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(x&lt;=N)&#123;<br>        c[x]++;<br>        x+=<span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Ins</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    tim[++len]=x;<br>    a[x]=len;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=limit;i++)&#123;<br>        <span class="hljs-keyword">if</span>(q[i]==<span class="hljs-number">0</span>)q[i]=len;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x%i&lt;=tim[q[i]]%i)q[i]=len;<span class="hljs-comment">//等于也要替换，因为优先输出后读入的</span><br>    &#125;<br>    <span class="hljs-built_in">Add</span>(x);<span class="hljs-comment">//加到树状数组里统计前缀和</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x)&#123;<br>        sum+=c[x];<br>        x-=<span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">low_find</span><span class="hljs-params">(<span class="hljs-type">int</span> ll,<span class="hljs-type">int</span> rr)</span></span>&#123;<br>    <span class="hljs-type">int</span> l,r,Min=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(ll==<span class="hljs-number">0</span>)l=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> l=ll;<br>    <span class="hljs-keyword">if</span>(rr&gt;N)r=N;<br>    <span class="hljs-keyword">else</span> r=rr;<br>    <span class="hljs-type">int</span> pre=<span class="hljs-built_in">front_sum</span>(l<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br>        <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> now=<span class="hljs-built_in">front_sum</span>(mid);<br>        <span class="hljs-keyword">if</span>(now&gt;pre)&#123;<span class="hljs-comment">//说明mid到l之间出现了值，向左找</span><br>            r=mid<span class="hljs-number">-1</span>;<br>            Min=mid;<br>        &#125;<span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<span class="hljs-comment">//没有值就向右找</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> Min;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<span class="hljs-keyword">return</span>;&#125;<br>    <span class="hljs-keyword">if</span>(x&lt;=limit)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,q[x]);<span class="hljs-keyword">return</span>;&#125;<br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=x<span class="hljs-number">-1</span>,ans=x<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;=N)&#123;<span class="hljs-comment">//判断左边界，判断右边界的话取值可能不完全</span><br>        <span class="hljs-type">int</span> now=<span class="hljs-built_in">low_find</span>(l,r);<br>        <span class="hljs-keyword">if</span>(now&amp;&amp;(now%x&lt;ans%x||now%x==ans%x&amp;&amp;a[now]&gt;a[ans]))&#123;<br>        <span class="hljs-comment">//等于和小于两种情况分开写，合在一起不行</span><br>            ans=now;<br>        &#125;<br>        l+=x;r+=x;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a[ans]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span>    cas=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n))&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=N;i++)&#123;<br>            tim[i]=a[i]=c[i]=q[i]=<span class="hljs-number">0</span>;<br>        &#125;<br>        len=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(cas)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %d:\n&quot;</span>,++cas);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">char</span> ss[<span class="hljs-number">5</span>];<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d&quot;</span>,ss,&amp;k);<br>            <span class="hljs-keyword">if</span>(ss[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;A&#x27;</span>)<span class="hljs-built_in">calc</span>(k);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">Ins</span>(k);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>早期水题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>树状数组</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
