<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2021</title>
    <link href="/2022/01/31/2021/"/>
    <url>/2022/01/31/2021/</url>
    
    <content type="html"><![CDATA[<h1 id="回忆·贰零贰壹"><a href="#回忆·贰零贰壹" class="headerlink" title="回忆·贰零贰壹"></a>回忆·贰零贰壹</h1><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>2021在不经意间就溜走了，退役之后一直有点遗憾当时在信奥的时候只留下了一堆的题解和学习笔记，没有写什么游记，所以打算在2021结束的时候写点东西，留住仅存的一点记忆。</p><h2 id="一月"><a href="#一月" class="headerlink" title="一月"></a>一月</h2><p>刺骨的寒风呼啸着从耳边吹过，我默默地站在明月初升的操场上，我是谁，我在哪？</p><p>由于一时的大意，我在 NOIp 的考场上犯了一个极大的失误，导致我以倒数的成绩留了下来，准备参加省队选拔，那一段时间真的过得挺痛苦的，一边是沉重的知识，一边是省赛失误的痛苦，还记得我当时每天早上6.50去吃饭，因为那时去就不用排队了，可以直接买，然后用五分钟吃完跑回机房考试，FFT，NTT，平衡树，反演等知识大部分都是在那个时间熟练掌握的，当时考试的成绩都还不错，以至于我对即将到来的 WC 充满了希望，当时除了奥赛生和高三的同学，学校里几乎已经没人了，我想，努力了这么半天，总该有点成效了吧。</p><p>怀揣着自信与紧张，我踏入了 WC 的考场，省赛的失误被我牢牢记住，这一次，我没有再出现任何失误，可是，题目我真的不会，即使拼尽全力绞尽脑汁，也只是获得了一个大众分，最终以一个铜牌收尾。</p><p>不过当时考完之后我们一群人聚在一起吃泡面的场景还是挺不戳的，还得知了自己只准备了不到几天的学考还撞大运的全 A 了，也算是寒冷中的一些温暖吧。</p><h2 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h2><p>春节，我的心情还是比较沉闷，一直在想，如果进不了省队会怎么样，我想，我大概会很失望伤心吧，大概要调整很长一段时间吧。于是那个春节，为了避免那种情况的发生，我几乎只在腊月三十的那天晚上休息了一会儿，跨了个年，然后就睡觉了，印象中第二天由于疫情原因并没有拜年，起床之后打了几个电话就又开始学习了。</p><p>现在的我貌似也挺佩服当时我的定力，或许如果前两个月我没有那么拼，结局可能就变了吧。</p><h2 id="三月"><a href="#三月" class="headerlink" title="三月"></a>三月</h2><p>春暖花开，我们开学了。</p><p>省选的战役也正式拉开帷幕，这个月出于某些奇怪的原因（其实是我忘了）和 $Longdie$ 的关系开始变好了，其实那个月大家的关系都比较融洽，后来由于和 $ LC $ 成了同桌，经常一起打一场比赛，或者刷一点水题，有时候 $Rubyonly$ 过来说一句，我给你看一个神仙题，这时候往往有两个结局，要么它真的神仙题，要么就是一个sb题，然而后者居多，经常被 $LC$ 一眼秒掉。$Kaiser_Kell$ 有的时候也会过来交流交流，总之，在静谧和谐的气氛中，省选到来了。</p><h2 id="四月"><a href="#四月" class="headerlink" title="四月"></a>四月</h2><p>临出发前，我们进行了一场十分水的信心赛，好像大家都 $AK$ 了，到了 sjz 之后，那个酒店的环境还是不错的，试了试机，感觉不是很适应 windows 的环境，不过已经到了这一步，也无所谓了吧，和 $Longdie$ 住了一间，为了攒rp晚上睡得都比较早，希望省选没事，省选的过程让人怀念，结局也出乎意料，由于不可抗力，HEOI又进行了一场加试，这大概是省选史上为数不多的加试吧，出于某些原因，不对加试题进行评价。</p><p>还记得考完的时候，为了避免再次出现不可抗力，决定这次用U盘拷贝两份代码，因此大家又等待了半个小时左右，那次确实是挺累的，从上午八点半到晚上七点多，我感觉最后那半个小时真的是度秒如年，出考场的时候，lin老师问day3的事，然后得知他t3推出了式子，而且出来的时候不知道是隔壁机房的谁在楼道里来了句t3挺水的，我当时一片空白，就有点心灰意冷的走了，因为临时加的赛所以也是临时定的晚饭，不过饺子确实好吃/赞，以为晚上可以在宾馆颓一晚上，结果被告知要连夜赶回去…………坐在回程的大巴上，和大家说着退役的事情，真的是十分伤心而又无可奈何，大巴弥漫着伤心的氛围，中途借学弟的手机和我妈打了个电话，讲了一些可能要退役的事。不出所料，第二天零点多才到学校，<del>你见过凌晨零点的hz吗</del>，第二天多睡了半个小时才起，学生会查内务的时候直接以得到年级主任的允许的名义把他们轰走了，略有一些爽，然后和 $Longdie$ 去吃饭，他当时的处境比我差很多，可以看得出来他心情不太好，吃完饭后他说打算回家准备 whk 了，不知道说什么只能安慰了他一下然后就自己去机房了。<br>到了机房之后大家开始用网上的数据测试全省的代码来估分，出乎意料的是，我竟然分数还比较高？更加出乎意料的是，lin老师竟然卡在了省队线上摆动，不过如果加上他第三天的那个结论题，应该问题不大。凯爹的分数好像也并不高，但是和大家的差距也不大，LC 的假做法拿多少分要看数据，我Day3基本没有分，这么一分析，好像hzoi只有$Kaiser_Kell$是稳进队的，那就只能等成绩了。<br><a href="https://www.cnblogs.com/anyixing-fly/p/14649281.html">关于省选只补充了一些之前没有写的</a><br>现在还记得当时大家在机房焦灼的等待的三天，<del>为了缓解氛围，还经常互奶一下</del>，CCF可以说是咕了又咕，依稀记得当成绩出来的时候，机房里悲喜交加，很多人的退役让我始料不及，是啊，有些人，就要说再见了，而对于我，好消息是进队了，坏消息是$Azusacat$凭借Day3干掉了我于是我就去了 B 队，从那时起，我几乎放弃了保送的希望，毕竟，对于一个 B 队选手来说，保送，还是很难的。出分后的第二天吧，我们就去了北京集训，见到了很多厉害的人，并且遇到了sjzez的同志们，这大概是及其罕见的两个学校一起集训吧，有了HEOI的感觉，在北京集训期间，明显感觉到做的题难度上升了，而且一个题一般要研究很久，一般一天能改完三道题就挺不错了，然后和 $Rubyonly$ 以及 $Kaiser_Kell$ 的良好关系逐渐形成了，<del>一个学地理的同学带着两个方位感并不好的同学在学校里找食堂</del>，不得不承认，他们的食堂确实很不错。</p><h2 id="五月"><a href="#五月" class="headerlink" title="五月"></a>五月</h2><p>回到学校后，过了几天，便踏上了清北营的路（尝到了lin老师亲自烤的肉/se），那是我第一次体会到了竭尽全力而又无能为力的感觉，也是我第一次感受到南方学校的强，某天考完试后，我和两位大佬走在回宾馆的路上，前边貌似是ZJ的几个初中生，其中一个说了句，今天的题<strong>挺简单</strong>，我直接人傻了，晚上和 <del>学弟</del> 学长出去转了一圈。回学校后就开始时不时纠结两个月后的全国赛，万一拿不到银牌怎么办，思索很长时间后，我告诉我，尽力就好。</p><h2 id="六月"><a href="#六月" class="headerlink" title="六月"></a>六月</h2><p>我们迎来了一个高考小假期，不过对于我们来说，其实和正常的生活没有什么不同，高考完我们也就成为了正式的高三，不过唯一和之前不一样的是我们几个人搬到了同一个宿舍，于是愉快的高三生活就开始了，第一天晚上，外边的水管漏水，虽然漏不到我们宿舍，但是，水滴声导致外边的声控灯一直响，我们宿舍简直和白天一样亮，为了好好休息，对，当时晚上基本上都是按时睡觉（，我们把门玻璃用硬纸板全挡上了，这就比晚上还黑。第二天下午正在改题的时候，突然得知被通报了，几个被子没有叠还有一个没被子的，我们觉得这可不行啊，内务不能被通报，于是后来我们每次出宿舍都顺便把门锁上，从此之后再也没被通报过了。</p><p>之后的生活也比较枯燥吧，考试-改题-吃饭-睡觉，偶尔趁机房空着的时候聊会儿天是非常不错的事情。</p><p>后来为了调整状态，安排了 sjzez 集训，<del>深入敌营</del>，第一天到的时候因为是从学校去的所以身上还穿着校服，可以说是回头率极高，然后出去吃了个饭换了个衣服，期间还借到了 $thecold$ 的校服，成功转校了属于是。</p><p>大概半个月的生活终于不那么枯燥了，除了考试外，还安排了几场ACM赛制，成功和zzz贴贴，由于zzz是Au爷所以我每次都是躺赢，sjzez的饭十分好吃/点赞，期间一直都比较和谐，只有最后一天出了点小状况，由于第二天就走了所以前一天大家都走的很早，第二天来了之后发现，<del>钥匙被锁机房里了</del>，最后是lin老师帅气跳窗户解决了问题。</p><p>临走前的那天起的很早，或许是睡不着，马上就走了想满足好奇心去他们存真楼里玩玩，但是没有理由担心进不去，于是想到了二北的四个人住在了上边，然后打算以找他们为借口溜进去转转，然而过程极其简单，<del>我在没人阻拦的情况下大摇大摆的进去了</del>。</p><h2 id="七月"><a href="#七月" class="headerlink" title="七月"></a>七月</h2><p>NOI要到了。</p><p>为了提前适应环境我们打算去镇海集训几天，然后十分不巧的是出发日期和UNR撞上了，于是开了个小号打UNR防止掉分，接着心态就炸了（，一 个 题 都 不 会。</p><p>在镇海的状态也还可以，基本保持每天过一个题的水平吧，我不求超常发挥，正常发挥我就已经满意了。</p><p>值得注意的是台风“烟花”即将登陆，而且风力越来越大，CCF紧急通知，可以自备救生衣，我？不过大部分人都没备，首先不在沿海应该被冲不了，其次真被冲了一个救生衣的作用也不太大，就没管。临近报道前几天，CCF又紧急通知，由于原定报道日烟花登陆，报道提前一天，好在我们已经到了镇海，去余姚挺近的所以没有什么影响。</p><p>报道后第二天原定报道日，一直的消息都是休息没有安排，结果CCF在中午双紧急通知三个小时后考笔试加试机，因为可能明天台风强度会更大。这直接让我无语。</p><p>不过台风的影响确实挺大的，北方人第一次见那么大的雨……而且雨都是<strong>横</strong>着飞的，十分壮观。</p><p><a href="https://www.cnblogs.com/anyixing-fly/p/NOI2021.html">NOI游记</a></p><h2 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h2><h2 id="九月"><a href="#九月" class="headerlink" title="九月"></a>九月</h2><h2 id="十月"><a href="#十月" class="headerlink" title="十月"></a>十月</h2><h2 id="十一月"><a href="#十一月" class="headerlink" title="十一月"></a>十一月</h2><h2 id="十二月"><a href="#十二月" class="headerlink" title="十二月"></a>十二月</h2><p>利益相关，暂不更新</p><p>二二高考，衡中必胜</p>]]></content>
    
    
    <categories>
      
      <category>回忆录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回忆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOI之后的碎碎念</title>
    <link href="/2021/08/01/noi/"/>
    <url>/2021/08/01/noi/</url>
    
    <content type="html"><![CDATA[<h1 id="NOI之后的碎碎念"><a href="#NOI之后的碎碎念" class="headerlink" title="NOI之后的碎碎念"></a>NOI之后的碎碎念</h1><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>本来想在 $NOI$ 之后写回忆录的，但是感觉写了会比较流水账，如果只写 $NOI$ 的游记又感觉少了点，所以就随便写写了，每个板块大概是独立的，不过总体还是按照时间顺序。</p><h2 id="我是怎么进入信息奥赛的"><a href="#我是怎么进入信息奥赛的" class="headerlink" title="我是怎么进入信息奥赛的"></a>我是怎么进入信息奥赛的</h2><p>初中的时候侥幸进入了衡水第一中学，然后又侥幸进入了夏令营，夏令营主要是让我们了解五大学科奥赛，记得当时虎哥（也就是我后来的教练）的宣讲十分给力，让我记忆犹新，当时对编程也十分感兴趣，所以想报信息奥赛，不过家长对奥赛不太感兴趣，不想让我报，最后争取了一下，还是决定试试，在报名的表格上随便填了三个奥赛，忘了除了信息还写了什么。</p><p>开学的时候被通知进入了奥赛班，竞赛生涯从此开始。</p><h2 id="联赛"><a href="#联赛" class="headerlink" title="联赛"></a>联赛</h2><p>由于$$F响应国家政策，NOIP 不收费，所以和往年相比我们还要参加一场 CSP，毕竟是第一次考试，考前还是十分紧张，进入考场后就好多了。</p><p>对于拿到题面时的场景，现在仍然记忆犹新，第一题是一个大模拟！我记得我当时读了很多遍题，来确定我是不是读错了，当时希望读错了题，它是个sb题，但是读了好多遍后，唯一确定的是它真的是大模拟，不过好在我调出来了，很多没有调出来的都挂了，带着过了大样例的兴奋去写第二题，实际上第二题是sb题所以很快就写出来了，但是挂了分，一些细节问题，这一场考试考的还不错，让我增长了许多信心，告诉我简单题不要轻敌，然而我并没有记住，NOIP又犯了致命错误。</p><p>NOIP的分数会被算到省队选拔中，怎么看都比CSP重要，不过并没有CSP时那么紧张，拿到题后第一眼就看出了第一题是sb题，然后很快写完了，很快踩坑了，这个坑直接让我的第一题从 $100$ 变成了 $60$，四十分的差距，当时看来是很大的，第二题很快就会了 $84$ 分的做法，由于正解想了很久也没想到，浪费了很多时间，所以最后两题都没怎么写，这一场是考挂了但是也没彻底考挂，搭上了去省选的末班车，在留下来省选的人中，我的成绩是倒数，压力很大。</p><h2 id="省队选拔"><a href="#省队选拔" class="headerlink" title="省队选拔"></a>省队选拔</h2><p><a href="https://suzipei.github.io/2021/04/12/heoi/">省选游记</a></p><p>NOIP之后，留下来的十几个人备战省选，这一段时间个人感觉是学习效率最高的时间，学会了很多算法，在模拟赛中偶尔也取得比较好的成绩，中间参加了一次冬令营，不过是线上的，而且打了 $Cu$ ，第一题其实很简单但是没想出来，现在想想或许有些遗憾？</p><p>四月到了，省选如期而至，在去省选的路上，我闭着眼想，如果退役了怎么办，大概会很伤心吧，怎么调整呢，大概也不会调整吧，总之就是感觉退役感很强，到了宾馆后也没有怎么疯狂颓，基本按照正常作息。</p><p>省选的第一天考完，我拿到了大概 $194$ 分，之所以说是大概，是因为没有评测，由于zzsz的原因，大家都没有提考试分数的事情，为了避免影响心态，只在回去的路上简单说了几句。</p><p>省选的第二天，我在考场上估分 $245$ ，感觉可以翻盘，那时候才长舒一口气，这一场几乎是没有什么失误，中间的一个小插曲是第一天代码丢了，所以加试了一场，加试的题目异常阴间导致大家的分数都差不多，除了一些大佬。</p><p>省选完的 $n$ 天，出了省选成绩，我进入了省队，既开心又难过，难过的是 $\color{red}Longdie$ 和 $\color{red}Liuchang$ 的退役，不知道怎么安慰他们，只能在心里默默祝愿他们在高考路上披荆斩棘。</p><h2 id="NOI前集训"><a href="#NOI前集训" class="headerlink" title="NOI前集训"></a>NOI前集训</h2><p>进入省队之后，教练认为在自己学校学习的效率很差所以要带我们出去集训，大概经历了两场集训，第一次是去首都师范大学附属中学，第二次是去石家庄二中，实际上恕我直言，在外面的效率不如在学校的效率，更真实的，在哪里效率都不高。。。。</p><p>在石二的时候和石二的省队拉近了关系，这或许是集训的最大收获（？），也意识到了省选完效率不高，所以会去写题解和给别人无偿讲题，可能是因为这些导致 $rp++$ ，颓了这么多国赛还没挂吧。</p><p>省选完后每天的状态大概就是，上午考试，下午改题讲题（×），大部分时间是颓，那段时间也比较开心？</p><p><del>顺便简单看完了几部电视剧</del></p><h2 id="National-Olympiad-in-Informatics"><a href="#National-Olympiad-in-Informatics" class="headerlink" title="National Olympiad in Informatics"></a>National Olympiad in Informatics</h2><p>全国赛最后还是来了，由于台风的影响所以行程飘忽不定，还好我们提前很多天到了浙江，在报道提前一天的情况下也到达了余姚。</p><p>和 $\color{red}pl_er$ 还有 $\color{red}Azusa_cat$ 一间宿舍，体验良好，第一天到了之后和 $\color{red}Azusa_cat$，$\color{red}Rubyonly$，$\color{red}Kaiser_Kell$ 打了半天王者，大概国赛的闲暇时刻不是在打王者就是在打lol，（不颓我也没事情干啊），哦除了背笔试。</p><p>有人说小道消息，笔试可能会提前一天，所以略微有点紧张，因为上午还在颓，下午笔试感觉会很惨，结果下午还真笔试了，中午十二点多接到通知下午笔试，日了狗了，然后就赶紧准备笔试，默念希望笔试没事。</p><p>笔试的时候$$F不讲武德，出了非题库里的考试题，好在有惊无险（都蒙对了），最后笔试成功 $AK$，这大概是唯一可以 $AK$ 的考试了吧，接下来由于有台风所以会有一整天的休息时间，然后就颓颓颓了。</p><p>实际上我是准备复习的，然后上午觉得下午可以复习，下午觉得晚上可以复习，晚上觉得明天，明天就开始考了？？于是开始复习，并且奶了一波不考 LCT，不考矩阵树定理，最后在十一点成功完成了复习计划——看 $\color{red}Liuchang$ 的博客。</p><p>拿到第一试的题目，发现第一题就是一个 LCT 的经典操作，简直是开幕雷击，不过仔细思考发现并不需要 LCT，随便用线段树维护一下就行，然后写了很长时间。。。。</p><p>第二题一眼看出了 $75$ 分做法，然后根据NOIP的经验，此时应该放弃第二题去拿第三题的部分分，当时已经猜到了第二题是把矩阵乘起来做行列式，但是就是没有写，去做第三题了，实际上现在想想如果去写第二题，第三题大概就没有时间写了，所以决策还挺正确的。</p><p>第三题是惊心动魄的一题，看了之后并没有仔细分析，就直接开始写了，决策是写暴力和树的部分分，实际上所有的问题可以转化为树不过并没有仔细想。。。本以为树十分好写可是却发现有很多情况需要分类讨论，并且讨论不是很简单，突然灵机一动，可以将所有点拉出来建虚树，这样直接做暴力即可，此时距离结束还有两个小时，写了有亿点长，到快结束的时候还没有调出来，然后听到了雪中送炭的加时五分钟，本来应该在两点结束的比赛延迟五分钟，此时我刚好发现边权不能直接放到点上，需要把边拆成点，于是赶紧改，最后成功在两点零二分通过了树的大样例，拿到了 $56$ 分。</p><p>之后查分，发现挂了 $20$，仔细一看多测没有读完，？？？？竟然只挂了 $20$ 分。</p><p>两试之间的那一天被我吃了所以没有，实际是颓的太开心了。。。</p><p>第二试的时候一眼就看出了第一题是个人类智慧题所以想了想发现不会就跳过去了，第二题简单想了想发现部分分很可写，第三题想了想发现不会，甚至连暴力分都打不太满，此时考试过去了大概一个半小时，没有任何进展，感觉这场要打挂了，当时应该是一个代码也没有写，直觉告诉我去看第二题，仔细分析一波发现加入字符之后对答案的影响实际上是一个矩阵的形式，只需要维护矩阵即可，套一个平衡树实现就好，但是感觉巨难写，不过此时只会写这个题了，于是决定写其它题的暴力，写第二题的正解，大概两个小时的时候，开始写第二题，没想到这题竟然这么难写，往往写着写着发现还需要加一个细节，考试一点结束，到十二点四十的时候我还在调，我告诉自己五十是最后的期限，五十如果还没调出来就立即停，然后五十的时候确实没有调出来，又是直觉告诉我传参传错了，马上改了一下，发现过了大样例，此时距离考试结束还有五分钟，不过紧张的心情立刻不紧张了，淡定的测了一下时间发现超时了，日了，用了三分钟的时间写了一个矩阵循环展开和快读，很佩服当时的手速，不过发现最大的点还是超时，那就这样吧，检查了一下文件名就结束了，真的，结束了。</p><p>出分之后果不其然超时了，不过拿到的分数也十分可观，看来是稳拿银牌了，也没有很伤心，毕竟在省选完的时候就意识到金牌不太可能了，虽然曾经也有过梦想，但是现实还是太残酷，比我厉害的人有很多，我不得不向后退一步。</p><p>晚上本来想晚睡一会儿，但是太困了所以十一点就睡了，其实也没有心情晚睡，一直在想着赶紧退役，等到真正退役的时候才发现有些难过，闭幕式上领到了奖牌，象征着竞赛生涯的结束，坐在闭幕式的位置上，我坐了很久，一直到虎哥提醒我可以走了，我才离开会场，心情比较压抑，但是也不知道怎么表达出来，或许只有经历过的人才能体会到吧，这种只可意会不可言传的感觉。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>不管怎么说，竞赛还是告一段落了，但是目前还是没有拿到约，或许没有学上了？我不是很清楚，反正这一段经历还是很难忘的。</p><p>各位，江湖再见了。</p><h2 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h2><p>感谢 $\color{red}Rubyonly$ 经常找辣鸡毒瘤题问我，让我增长见识</p><p>感谢 $\color{red}SueJane$ 学姐的帮助，让我看到前进的希望</p><p>感谢教练和家长的鼓励与支持</p><h2 id="最后的最后的最后"><a href="#最后的最后的最后" class="headerlink" title="最后的最后的最后"></a>最后的最后的最后</h2><p>已经AFO回归文化课了，不过还是放不下OI，比如在听到逆否命题时会想起2-sat，看到矩形时会想起矩形面积并的扫描线做法，想到数列递推时会想起矩阵快速幂等等，这些影响，或许只能靠时间消磨了。</p>]]></content>
    
    
    <categories>
      
      <category>回忆录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回忆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HEOI 退役记</title>
    <link href="/2021/04/12/heoi/"/>
    <url>/2021/04/12/heoi/</url>
    
    <content type="html"><![CDATA[<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day-1"></a>Day-1</h2><p>中午要出发，上午还要考试就离谱，不过大家考前都说爆零攒 rp 但是一考试一个比一个猛，坐 $L\color{red}{ongdie}$ 旁边，开场发现 T2 之前见过类似的思路，不过为了攒 rp 没有马上写，看 T1 发现70分挺 sb 的，不过剩下的东西有亿点恶心，读入都是高精，就先写了 70,写完发现 $L\color{red}{ongdie}$  已经开始码 T1 了，而且看上去时间复杂度挺对的，<del>不过最后爆零了</del>，最后在一系列打表找规律等操作下，发现读入可以直接取模，然后暴力做就行了，<del>剩下两题过水直接AK了</del>，rp–。</p><p>下午到了sjzez，试机打算敲一个 ntt 和 fft 对拍，不过由于还要测一些东西导致最后的时间不多了，ntt 打完但是 fft 没写完，rp– ，被拉去开防疫会了，实际上感觉就是给教练说没人搭理他们然后给我们开会好让我们回去吓唬教练，不过全程没怎么听他的。</p><p>开完会貌似还能试机，火速回去打完了 fft ，然后一下就拍上了，rp++，不过感觉对拍速度十分慢，虚拟机还是不大行啊，最后把对拍的输出改成了 HZOI always win，<del>半年没学whk了不知道英语语法对不对</del>。</p><p>回去的路上经过超市买了许多东西，$L\color{red}{ongdie}$ 没带钱所以顺便帮他付了，rp++。</p><p>晚上的盒饭十分不大行，我寻思着一天一百的盒饭就这啊？第二天考试，所以晚上也没干啥就睡觉了。</p><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>虽然之前模拟过很多场了但是还是挺慌的，到了 sjzez 之后在大门面前待了一会儿就进去了，感觉时间过的挺快，现在也是，貌似刚刚还在省选，殊不知已经过去了两天。</p><p>进入考场之后管的比较严，不让动键盘鼠标，左边是 sjzez 的 zzz ，再左边是  $L\color{red}{in4xu}$ ，有点慌，不过马上感觉也没啥，反正也看不见他们的屏幕，也不知道他们在干啥。</p><p>开场先看三道题，题面貌似都比较短，很阳间，读一遍题之后感觉 T1 是一个 sb 的二分答案，不过具体实现还要想一想，T2 是一个比较神仙的构造题，T3 是一个图论，看上去更神仙。</p><p>于是决定先写 T1 ，顺序开题，想了想发现如果二分极差的话可以将所有数锁定在一个区间内，而区间的左端点只有 $n$ 种，这样只需要判断一个前缀和一个后缀翻转后是否合法即可，于是直接开始写，大概写了十分钟，此时只过去了半个小时，感觉状态挺不错，<del>然后发现连最小的样例都过不去</del> 。</p><p>慌了一下，不过马上调整然后调代码，发现实际上左端点有 $2n$ 个，改完之后直接过了三个样例，大概看了一眼大样例不是很水的样子，所以没管，去看 T2 了，由于 noip 的劣势导致我省选貌似不得不 AC 一道不是很签到的题才能扳回来，于是并没有选择对拍。</p><p>T2 想了一个小时，这啥啊，这怎么做啊，这完全不会啊，冷静一下发现 $n,m\leq3$ 都不会做，那这不是玩完了。</p><p>又想了半个小时发现 $m=2$ 的情况实际上变量很少，暴力枚举第一个是啥或许可以，不过仔细分析一下时间复杂度还是太高了，尤其是多组数据。</p><p>又仔细分析一波发现可以对于每个变量解一个不等式得到第一个变量的取值范围，然后随便取一个在范围内的貌似就可以，三十分到手，直接开始写。</p><p>很快写完了，自己造了几组感觉没啥问题，又又仔细分析了一波发现这个完全可以套到 $m$ 不是 $2$ 的情况，对行做一遍对列做一遍就能得到边界上每两个相邻元素的取值范围，不过剩下的就不大会了，而且感觉细节特别多，此时已经过去两个半小时，于是决定先去看 T3 ，不知道为啥一看 T3 就觉得十分不可做，虽然潜意识里觉得这样想会出问题，不过当时确实感觉不可做，如果那是一道水题那我必完，所以最好还是避免这种直观上对题目难度的判断。</p><p>基于直观上的判断，本来想直接打 $16$ 分就走人的，但是又感觉 $44$ 分挺好打的<del>实际上是我不会写16</del> ，过了一会儿发现本质上可以考虑每个点的恭喜，一个点会贡献到另一个点当且仅当两点间的路径上的点编号都不小于这个点，所以动态加边就挺对的，大概分析一下是 $O(nm+mn^2)$ 的？反正看上去就挺能过的，很快敲完了然后又<del>过不去样例</del>，调了一会儿发现读错题了，不过问题不大，稍微改了一下就过了，大样例跑 $0.1$ 秒，感觉 $44$ 有了。</p><p>此时距离考试结束还有一个小时，不过对 T2 的想法很成熟，估计可以过，如果能AC的话那我 Day1 244感觉挺稳，于是直接写 T2，不到三十分钟就写完了，一遍过了三个样例，但是样例比较水，打算自己造几个，首先造了几个比较小的，发现都挺对的，<del>woc，我貌似写对了？？？</del>，保守起见随了一组比较大的数据，然后一眼发现不对劲，怎么还有负数啊？</p><p>然后开始疯狂 Dbug，输出后发现边上的数解出的范围都是对的，但是一代入就挂了，什么情况。。。</p><p>最后发现是不能很好的构造一组边角上的数使得它们满足不等式的限制，然后就挂了，由于是一组不等式的形式，所以想了一下差分约束，但我的不等式中有类似 $x_1+x_2\leq a$ 的形式，这咋差分约束啊，不大会，但是 $n,m\leq3$ 好像挺对的，于是此时估分 $ 100+50+44 = 194$，距离考试结束还有十五分钟，打算回去检查代码，剩下的时间也没干啥。</p><p>考完之后离开考场，在楼梯口碰见了$H\color{red}{ISkrrr}$ 和$K\color{red}{aiser_Kell}$ ，然后就一起出去了。</p><p>走出考场碰到老姚，让我们先回宾馆，然后就边走边聊，大概吐槽了一下考试题，而且我还大胆猜测 $L\color{red}{ongdie}$ 和 $L\color{red}{iuchang}$ 有一个人 A 了 T2，所以我就退役了（？），不知道为啥就是直觉，然后就瞎聊了半天，忘了聊啥了。。。。。</p><p>到宿舍之后发现 $L\color{red}{ongdie}$ 还没回来，打算去转一圈，然后他就回来了，一起期待中午的盒饭能吃一点，毕竟是一百的盒饭，后来发现就这啊，还不如泡面。</p><p>下午和 $R\color{red}{ubyonly}$ 玩了一下午，本来说查代码的，但是一直没查，也没太在意（伏笔1）。</p><p>晚上睡觉最开始还是睡不着，就比较困，但是睡不着，不过躺着躺着就睡着了。</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>由于第一天已经考过一次了，所以这次并没有很紧张，坐到位置上后等了一会儿就开始了。</p><p>T1这一眼数据结构题吧，貌似有点线段树维护单调栈的感觉？不过不大会，先放一放。</p><p>T2一眼状压，不过状态不是很会定义，先放一放。</p><p>T3一眼不会，有支配，这不会是支配树吧，不过可能也不是，我没学过也不知道支配树是干啥的啊。</p><p>最后决定先开 T2 ，因为这种状压一般比较好写，但是想了半个小时发现还是只会 $O(n!n)$，而且感觉再想下去可能没有什么进展，有一个差分的思路但是很快假了，决定打完 $O(n!n)$ 就去写 T1 ，打完之后又没过样例，rp–，模拟了一遍甚至以为样例假了，那这把好像不太好整，感觉 T1 和 T2 都有思路但是都整不出来，告诉自己别急，然后开始重新模，发现要求公布的 $b_i$ <strong>单调不降</strong>，于是随便改改就过了，$ 60 $ 应该有了，所以去写 T1 。</p><p>直觉上感觉这个东西只要把链的写法想出来然后扔到树上就能过，所以先想链的写法。</p><p>貌似做法就是直接扫一遍然后如果当前的数是我想要的就++，不过这个数貌似只能扫一遍判断，诶不过要是离散化一下那不就相当与从 $1$ 开始走吗，那就对于每个数只需要找第一个大于它的数，然后往后跳，那倍增一下是不是就 $\log$ 了，诶好像有了。</p><p>在树上首先把路径劈成两半，$x$ 到 $lca$ 可以用向上倍增解决，$lca$ 到 $y$ 咋办，不大会了，貌似也可以倍增但是这次要倒着跳，倒着跳咋跳啊，没有起点？好像可以二分一下，这样就有重点了，貌似也有单调性，那直接写一发吧，考试开始一个小时半A掉Day2的一道题，还不错。</p><p>写完之后发现过不了样例，晕，不过把倍增改成暴力就能过样例，所以应该是细节挂了，然后拍了一个小数据，调了调发现应该把二分边界改一下，然后就过样例了，感觉挺好的，突然想起来如果T2的 $b_i$ 是单调不降的那么我那个差分貌似又真了，于是立刻去写T2的状压，大概两个半小时的时候就写完了，不过时间复杂度好像有点爆炸，$O(2^{13}mn^2)$ ，那个 $n^2$ 看起来就挺假的，突然怀疑能不能跑过最大的数据，顺手剪了几个枝，然后测极限数据，$0.3$ 秒？跑这么不满，那好像没啥事了，又随了几组数据，发现效果还行，此时估分 $194+100+100$，感觉挺高的，但是既然我都过了，$L\color{red}{ongdie}$ 和 $L\color{red}{iuchang}$ 应该也差不多吧，那我还翻个啥盘啊，当时感觉胜利与否在于 T3 拿多少分。</p><p>最开始的暴力都不会打，想想貌似可以删除一个点然后看看一号节点能到那些点，这样做大概就有暴力分了，先写了一发过了样例，此时感觉对于正解仍然没有思路，所以打算把暴力分都拿到，开始写树的，写完之后随了几组数据都挺对的，然后就没管它，此时距离考试结束还有不到一个半小时，感觉希望有些渺茫然后开始算分，$194+100+100+45=439$，好像有点高？那是不是挺稳的？</p><p>想着想着突然发现会不会建出支配树后套上树的做法就能AC，猜测可能是这样，但我不会建支配树啊，没事可以 $n^2$ 建树，然后就自己口胡了一个支配树上去，套上树的做法，竟然一下过了三个样例！</p><p><del>第三个样例看上去就不是很水</del>，于是我AK了？</p><p>现在估分$194+100+100+100=494$，有点起飞的感觉，此时还有大概一个小时左右，为了求稳要去打一下对拍，第一题直接过了对拍，第二题也是，but 。</p><p>第三题拍了几组就挂了，以为是数据造错了然后手模了一下，发现这玩意根本就不对好吧，这大样例咋回事啊，这是什么鬼啊，于是估分 $194+100+100+45=439$，<del>我回来了</del>。</p><p>然后内心骂了半天T3出题人，怎么大样例这么水，希望别有人被坑了，后来想了半天也没想出来怎么解决这个问题，貌似需要访问一遍支配树上的父亲，然后还要统计一些东西？不大会，然后就想不出来了，最后考试结束了。</p><p>老师掏出一个 U 盘，说确定好代码后再走，以为是Day2所以用 U 盘拷走（伏笔2），然后就弄了亿分钟，我退役感言差不多也想好了，最后突然又让教练们进来，不知道那人是谁，开始宣读一张纸，具体读了啥我也忘了，在当时那种情况下，我几乎只听清了关键字——加试，然后我人就傻了，貌似是因为第一天的码由于不可告知的原因没了，所以要补一场考试，下午三点开始，我一看时间现在都快两点了，还没吃饭，一会儿发了盒饭，不过没有心情吃，就吃了一点就睡觉了，桌子还挺硬，所以把校服脱下了垫着（我怀疑这是我现在感冒的原因），我也不知道睡没睡着，很快就开考了。</p><p>一看只有一个不到 $500K$ 的压缩包，怀疑没有大样例，公布密码后确实没有，更 $ NB $ 的是，题面竟然是图片加文字，配个图是什么鬼啊？更更 $NB$ 的是，上边写着 $NOI2011$ 福建省省选，加试整个十年前的题是什么意思啊，不是说备用题吗？？更更更 $NB$ 的是，题面没有编译选项。。。</p><p>开场看题，T1 貌似是一个字符串，T2 是立体几何，这做啥啊，球的表面积都忘了，并且猜测这题 $HE$ 应该都是爆零，所以不打算想了，T3 是一个推式子的，但是递推关系不是常系数，也没啥思路，打算一会儿写个高斯消元看看。</p><p>于是开始写T1，想了半天也没啥思路，先打了一个暴力，然后觉得这样不大行，不过猜测如果是十年前的题是不是数据会水一些，于是打了 SAM 上爆跳父亲更新答案，随机数据跑的很快，三十分应该有了，想了大概两个小时左右还是不会，然后就跳过去了。</p><p>看了一下 T2 ，觉得二十分可以想想，此时感觉下午只要打好暴力就差不多了，想了半天还是不会二十，貌似十分不可做，直接撤了，输出一个 $0$ 就跑路了。</p><p>把希望放在最后的 T3 上边，全文搜索质数，$0$ 个结果，cao，模数不是质数，那暴力分都拿不到？？</p><p>感觉模数不是质数可以扩展卢卡斯，不过是偶数的话就没有逆元了，咋整？推了半天还是没啥思路，根本就推不动，所以只能赌他模数有奇数的情况了，不过是多测啊，那也不能坐着待着吧，所以就用最后一段时间写了一个扩展卢卡斯，退役感爆棚，本来估分 $400+$，现在 $300$ 都不到，听天由命了。</p><p>考完之后又是用 U 盘收，等了半天，很头疼。</p><p>出考场后问了问大家的分数，貌似都不是很高，最高在 $60$ 分左右，不过据说一个学弟 A 了 T1，而且 $L\color{red}{iuchang}$ 打了 $60$ ，算一下貌似会死， $L\color{red}{ongdie}$ 貌似今天考挂了，希望他没事，到了车上和大家聊了聊天就睡觉了，困的要死，到学校已经深夜十二点了，回宿舍就直接睡觉了，第二天晚起了一会儿，挺困的，去了机房后用民间数据测了一下，没有挂分，而且据说我们考的确实是今年的福建省选，而不是 $2011$ 的，<del>那我SAM不是稳挂吗</del>，现在就等出分了。</p><p>update:出分了，不过因为数据锅了好像要重测，然后 $L\color{red}{ongdie}$ 有可能能进，还不太好说，希望他能进。</p>]]></content>
    
    
    <categories>
      
      <category>回忆录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回忆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>另一元宵节 线段树</title>
    <link href="/2020/03/08/hzoi0002/"/>
    <url>/2020/03/08/hzoi0002/</url>
    
    <content type="html"><![CDATA[<p><img src="hzoi0002.png"></p><p>其实最开始这个题我没做出来是因为我不知道&amp;是啥意思，我以为是加和</p><span id="more"></span><p>这个题的意思其实就是让构建一个数组，使它的某个区间按位与的和为一个数，看看会不会产生矛盾。</p><p>知道这一点后就好办了，新建一个为0的数组，每次查询就 | 一下，然后查询区间按位与的和，看看符不符合]</p><p>为什么要 | 呢？</p><p>这要考虑&amp;是怎么运算的了</p><p>在二进制位下，只有两个数字的某一位上都是1，&amp;出来才是1，所以也有一个很显然的问题，&amp;出来的数不一定与区间内的每一个数相等</p><p>但他们的二进制位下，&amp;出来的数的二进制位一定相等，所以每次查询的时候把要查询的那个数对应的二进制位 | 一下就行了</p><p>然后就是线段树的板子吧，这里不能用树状数组，想想为什么</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br>ll tree[N],lazy[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updata</span><span class="hljs-params">(<span class="hljs-type">int</span> rt,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,ll w)</span></span>&#123;<br>    tree[rt]=tree[rt]|w;<br>    lazy[rt]=tree[rt]|w;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> rt,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">updata</span>(rt&lt;&lt;<span class="hljs-number">1</span>,l,mid,lazy[rt]);<br>    <span class="hljs-built_in">updata</span>(rt&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,lazy[rt]);<br>    lazy[rt]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> rt,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> t,ll w)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s&lt;=l&amp;&amp;r&lt;=t)&#123;<br>        <span class="hljs-built_in">updata</span>(rt,l,r,w);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">pushdown</span>(rt,l,r);<br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(s&lt;=mid)<span class="hljs-built_in">modify</span>(rt&lt;&lt;<span class="hljs-number">1</span>,l,mid,s,t,w);<br>    <span class="hljs-keyword">if</span>(t&gt;mid)<span class="hljs-built_in">modify</span>(rt&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,s,t,w);<br>    tree[rt]=tree[rt&lt;&lt;<span class="hljs-number">1</span>]&amp;tree[rt&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> rt,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> t)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s&lt;=l&amp;&amp;t&gt;=r)<span class="hljs-keyword">return</span> tree[rt];<br>    <span class="hljs-built_in">pushdown</span>(rt,l,r);<br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(t&lt;=mid)<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rt&lt;&lt;<span class="hljs-number">1</span>,l,mid,s,t);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s&gt;mid)<span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rt&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,s,t);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(rt&lt;&lt;<span class="hljs-number">1</span>,l,mid,s,t)&amp;<span class="hljs-built_in">query</span>(rt&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r,s,t);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> m,n,t;<span class="hljs-type">bool</span> flag;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;kuai.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;kuai.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>        flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">memset</span>(tree,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(tree));<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-type">int</span> l,r;<br>            ll w;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%lld&quot;</span>,&amp;l,&amp;r,&amp;w);<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,l,r,w);<br>            ll data=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,l,r);<br>            <span class="hljs-keyword">if</span>(data!=w)flag=<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>早期水题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOI ONLINE 提高组 序列</title>
    <link href="/2020/03/08/noionline/"/>
    <url>/2020/03/08/noionline/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><span id="more"></span><p>小 D 有一个长度为 $n$ 的整数序列 $a_{1 \dots n}$，她想通过若干次操作把它变成序列 $b_i$。</p><p>小 D 有 $m$ 种可选的操作，第 $i$ 种操作可使用三元组 $(t_i,u_i,v_i)$ 描述：若 $t_i=1$，则她可以使 $a_{u_i}$ 与 $a_{v_i}$ 都加一或都减一；若 $t_i=2$，则她可以使 $a_{u_i}$ 减一、$a_{v_i}$ 加一，或是 $a_{u_i}$ 加一、$a_{v_i}$ 减一，因此当 $u_i=v_i$ 时，这种操作相当于没有操作。</p><p>小 D 可以以任意顺序执行操作，且每种操作都可进行无限次。现在给定序列与所有操作，请你帮她判断是否存在一种方案能将 $a_i$ 变为 $b_i$。题目保证两个序列长度都为 $n$。若方案存在请输出 <code>YES</code>，否则输出 <code>NO</code>。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>本题输入文件包含多组数据。</p><p>第一行一个正整数 $T$ 表示数据组数。对于每组数据：</p><p>第一行两个整数 $n,m$，表示序列长度与操作种数。</p><p>第二行 $n$ 个整数表示序列 $a_i$。</p><p>第三行 $n$ 个整数表示序列 $b_i$。</p><p>接下来 $m$ 行每行三个整数 $t_i,u_i,v_i$，第 $i$ 行描述操作 $i$。</p><p>注意：同一个三元组 $(t_i,u_i,v_i)$ 可能在输入中出现多次。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>对于每组数据输出一行一个字符串 <code>YES</code> 或 <code>NO</code> 表示答案。</p><h1 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h1><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">5</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h1 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h1><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">YES</span><br><span class="hljs-keyword">YES</span><br><span class="hljs-keyword">YES</span><br></code></pre></td></tr></table></figure><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><p>第一组数据：使用一次操作 $1$。<br>第二组数据：使用三次操作 $1$。<br>第三组数据：使用三次操作 $1$，令 $a_1,a_2$ 都增加 $3$，再使用一次操作 $2$，令 $a_1,a_3$ 都增加 $1$。</p><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>对于测试点 $1 \sim 5$：$n=2$，$m=1$，$a_i,b_i \le 99$，$u_1 \ne v_1$，$t_1=1$。<br>对于测试点 $6 \sim 10$：$n=2$，$m=1$，$a_i,b_i \le 99$，$u_1 \ne v_1$，$t_1=2$。<br>对于测试点 $11 \sim 12$：$n=2$，$a_i,b_i \le 99$，$u_i \ne v_i$。<br>对于测试点 $13 \sim 16$：$t_i=2$。<br>对于测试点 $17$：$n,m \le 20$。<br>对于测试点 $18$：$n,m \le 10^3$。<br>对于所有测试点：$1 \le T \le 10$，$1 \le n,m \le 10^5$，$1 \le a_i,b_i \le 10^9$，$t_i \in {1,2}$，$1\le u_i,v_i \le n$。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>说实话第一眼看到这题的时候我有点懵，真不知道怎么做，不过一看数据，还好还好，暴力能拿一半分，于是我就真拿了一半分。。。。。</p><p>但某大佬说暴力能拿60，但我拿一半就满意了   我不会啊</p><p>考完后忍不住好奇这道题要怎么做，于是就看了看题解，发现题解也。。。有点难懂，主要是我看到一个字，图？？这明明是个数的问题咋还和图扯上了关系，awsl，果然还是我太菜了</p><p>仔细读了一下，明白了一些。先看操作一：如果有(a1,a2)(a2,a3)(a3,a1),那么其中任意一个数都能自己加减二，如a1，a1+1,a2+1,a2-1,a3-1,a3+1,a1+1这样就能让a1自己加减二，同理a1换成任何数都可以，这里要注意，必须是奇数个点并且形成环才能这样办，所以每个奇数环上的数都能加减二，偶数个点为什么不行自己举个例子就明白了。再看操作二：如果有(a1,a2)(a2,a3)那么可以知道(a1,a3)，a1+1,a2-1,a2+1,a3-1由此,a1+1，a3-1，可见操作二是具有传递性的，如果把它们看做是一个联通块，那么这个联通块可以任意加1，减1，所以如果这个联通块需要加的值和需要减的值一样，那么就满足。于是我们只要把每个操作二都缩成点，每个操作一建边，然后开始判断每块联通块是不是满足题意。</p><p>判断方法为，如果未形成奇数环，则需要使联通块内相加的数与相减的数相等，因为只能加一减一，否则使需要变化的总数是偶数即可，注意自环也要判断，因为自环相当于(a1,a2,1)(a1,a2,2)即a1+1,a2+1,a2-1,a1+1,这样也能使任意数加减二，</p><p>然后还有就是对于没有边连入的点，只有需要变化的值为0，才满足，因为没有边可以使它产生变化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> val[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> to,next;<br>&#125;e[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> t,u,v;<br>&#125;p[N];<br><span class="hljs-type">int</span> Head[N],len,sum,flag;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Ins</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[++len].to=b;e[len].next=Head[a];Head[a]=len;<br>&#125;<br><span class="hljs-type">int</span> f[N],belong[N],a[N],b[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> f[x]==x?x:(f[x]=<span class="hljs-built_in">find</span>(f[x]));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Mer</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-type">int</span> u=<span class="hljs-built_in">find</span>(a),v=<span class="hljs-built_in">find</span>(b);<br>    <span class="hljs-keyword">if</span>(u!=v)&#123;<br>        f[u]=v;val[v]+=val[u];<span class="hljs-comment">//并查集缩点</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> bin)</span></span>&#123;<br>    belong[x]=bin;<br>    <span class="hljs-keyword">if</span>(bin)sum+=val[x];<br>    <span class="hljs-keyword">else</span> sum-=val[x];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=Head[x];i;i=e[i].next)&#123;<br>        <span class="hljs-type">int</span> v=e[i].to;<br>        <span class="hljs-keyword">if</span>(belong[v]==<span class="hljs-number">-1</span>)<span class="hljs-built_in">dfs</span>(v,bin^<span class="hljs-number">1</span>);<span class="hljs-comment">//利用了^的性质</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(belong[x]==belong[v])<span class="hljs-comment">//说明v已经被提前访问过并且bin的值与x一样，那么就一定形成了奇数环</span><br>            flag=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//    freopen(&quot;a.txt&quot;,&quot;r&quot;,stdin);</span><br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>    <span class="hljs-keyword">while</span>(t--)&#123;<br>        <span class="hljs-type">int</span> m,n,ans=<span class="hljs-number">1</span>;len=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;b[i]),val[i]=b[i]-a[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            f[i]=i,belong[i]=<span class="hljs-number">-1</span>,Head[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;p[i].t,&amp;p[i].u,&amp;p[i].v);<br>            <span class="hljs-keyword">if</span>(p[i].t==<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-built_in">Mer</span>(p[i].u,p[i].v);<span class="hljs-comment">//合并操作二</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-keyword">if</span>(p[i].t==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-built_in">Ins</span>(<span class="hljs-built_in">find</span>(p[i].u),<span class="hljs-built_in">find</span>(p[i].v));<span class="hljs-comment">//这里已经缩点所以要合并根</span><br>                <span class="hljs-built_in">Ins</span>(<span class="hljs-built_in">find</span>(p[i].v),<span class="hljs-built_in">find</span>(p[i].u));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i)==i&amp;&amp;belong[i]==<span class="hljs-number">-1</span>)&#123;<br>                flag=sum=<span class="hljs-number">0</span>;<br>                <span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=Head[i];x;x=e[x].next)&#123;<br>                    <span class="hljs-keyword">if</span>(e[x].to==i)flag=<span class="hljs-number">1</span>;<span class="hljs-comment">//自环</span><br>                &#125;<br>                <span class="hljs-keyword">if</span>(Head[i]==<span class="hljs-number">0</span>&amp;&amp;sum!=<span class="hljs-number">0</span>)ans=<span class="hljs-number">0</span>;<span class="hljs-comment">//没有边连入</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>&amp;&amp;sum%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)ans=<span class="hljs-number">0</span>;<span class="hljs-comment">//奇数环</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>&amp;&amp;sum!=<span class="hljs-number">0</span>)ans=<span class="hljs-number">0</span>;<span class="hljs-comment">//偶数环</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ans)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>思维题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POJ 1062 昂贵的聘礼</title>
    <link href="/2020/03/07/poj1062/"/>
    <url>/2020/03/07/poj1062/</url>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>年轻的探险家来到了一个印第安部落里。在那里他和酋长的女儿相爱了，于是便向酋长去求亲。</p><span id="more"></span><p>酋长要他用10000个金币作为聘礼才答应把女儿嫁给他。探险家拿不出这么多金币，便请求酋长降低要求。酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要8000金币。如果你能够弄来他的水晶球，那么只要5000金币就行了。”探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。另外他要告诉你的是，在这个部落里，等级观念十分森严。地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。他是一个外来人，所以可以不受这些限制。但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。因此你需要在考虑所有的情况以后给他提供一个最好的方案。 <br>为了方便起见，我们把所有的物品从1开始进行编号，酋长的允诺也看作一个物品，并且编号总是1。每个物品都有对应的价格P，主人的地位等级L，以及一系列的替代品Ti和该替代品所对应的”优惠”Vi。如果两人地位等级差距超过了M，就不能”间接交易”。你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。 </p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>输入第一行是两个整数M，N（1 &lt;= N &lt;= 100），依次表示地位等级差距限制和物品的总数。接下来按照编号从小到大依次给出了N个物品的描述。每个物品的描述开头是三个非负整数P、L、X（X &lt; N），依次表示该物品的价格、主人的地位等级和替代品总数。接下来X行每行包括两个整数T和V，分别表示替代品的编号和”优惠价格”。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出最少需要的金币数。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">10000 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">8000</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5000</span><br><span class="hljs-symbol">1000 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">200</span><br><span class="hljs-symbol">3000 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">200</span><br><span class="hljs-symbol">50 </span><span class="hljs-number">2</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">5250</span><br></code></pre></td></tr></table></figure><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>输出最小的金币数，这道题首先想到的就是建图跑最小路，我最开始用的方法是根据所给信息把边权和点权都加上，然后在跑Dij的时候判断</p><p>如果选择边权，那么还要加和这个点的儿子的权，如果选择点权就不用，然后统计到各个点最小距离。</p><p>打了一下样例没过，然后回去想，发现加的是双向边，于是又加了一个vis数组判断是否访问过，这次样例过了，交上去WA</p><p>再仔细想一下，先不管我的点权和边权处理有没有问题，就一个问题是很难解决的，就是终点是什么，不一定所有的点都能当做本次统计的终点</p><p>也就是说它会直接返回最小值，不管这个最小值是不是已经把所有需要的点权边权都包括进去了，比如我要买二号物品来降低一号物品价格，在统计</p><p>到二号物品的路程时，直接返回了边权，但点权也是应该加上的，所以没有选完全，我感觉还是我的程序有问题　</p><p>重新思考，有没有一种方法能够让程序自动判断选择边权还是点权，并且终点是一样的？</p><p>受如果使用该物品的话边权和点权必选其一的启发，我们可以采用超级源点，即把所有的点的点权作为这个点和超级源点的边权，于是又跑一遍</p><p>又没过样例，这次我发现一个问题，我加的是双向边，而加双向边是肯定不行的，因为边权表示买二号物品得到三号物品的优惠，如果加双向的话就</p><p>表明买三号物品也能得到二号物品的优惠，这显然是不对的，于是我们考虑边的方向，从源点出来，边的去向一定是指向每个点，因为我们是以源点</p><p>为起点，一号物品为终点跑的Dij，所以输入时，如果买a对b有优惠，那么Add_Edge(a-&gt;b)，这样就可以保证终点是一样的，且最短路径上每个点的</p><p>点权或边权都被选完全了。</p><p>修改完代码，测了测样例，对了！然后交上去，WA。。。。</p><p>接着我思考半天后找到了我最开始过深考虑的问题——等级，我起初是怎么处理的呢？我在建图时判断，如果一个点的等级与第一物品的差值的</p><p>绝对值小于m，就不加这个点及其周围的边。这么看好像是对的，举个例子，m=3，level[1]=8,我们买了level[2]=6,level[3]=10的两个物品，由题意，</p><p>这不被允许，所以不能这么判断，但这给了我一个启发：买的物品价值范围（levelmax-levelmin&lt;=m）,所以我们可以考虑枚举物品的价值范围，每次</p><p>对于枚举的范围进行Dij求最短路，输出最短的路径即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">110</span>,INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> to,next,val;<br>&#125;e[N*N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> id,val;<br>    <span class="hljs-built_in">Node</span>()&#123;&#125;;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)&#123;id=a;val=b;&#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Node&amp;A)<span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> val&gt;A.val;<br>    &#125;<br>&#125;;<br><span class="hljs-type">int</span> Head[N],len,lev[N],ans,m,n,dis[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Ins</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    e[++len].to=b;e[len].val=c;<br>    e[len].next=Head[a];Head[a]=len;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dij</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span></span>&#123;<br>    priority_queue&lt;Node&gt; q;<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>    dis[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Node</span>(<span class="hljs-number">0</span>,dis[<span class="hljs-number">0</span>]));<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        Node u=q.<span class="hljs-built_in">top</span>();q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=Head[u.id];x;x=e[x].next)&#123;<br>            <span class="hljs-type">int</span> v=e[x].to;<br>            <span class="hljs-keyword">if</span>(lev[v]-level&gt;m||lev[v]&lt;level)<span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(dis[v]&gt;dis[u.id]+e[x].val)&#123;<br>                dis[v]=dis[u.id]+e[x].val;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Node</span>(v,dis[v]));<br>            &#125;<br>        &#125;<br>    &#125;<br>    ans=<span class="hljs-built_in">min</span>(ans,dis[<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// freopen(&quot;a.txt&quot;,&quot;r&quot;,stdin);</span><br>    <span class="hljs-type">int</span> selfval;<br>    ans=INF;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;selfval,&amp;lev[i],&amp;c);<br>        <span class="hljs-built_in">Ins</span>(<span class="hljs-number">0</span>,i,selfval);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=c;j++)&#123;<br>            <span class="hljs-type">int</span> a,b;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<br>            <span class="hljs-built_in">Ins</span>(a,i,b);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lev[<span class="hljs-number">1</span>]-m;i&lt;=lev[<span class="hljs-number">1</span>];i++)<br>        <span class="hljs-built_in">dij</span>(i);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> </p><p>这个问题看起来还是比较难的，但是想明白以后也比较简单，下次在做题的时候一定把问题先想清楚，边做边想太难了。。。。。。</p><p> </p>]]></content>
    
    
    <categories>
      
      <category>早期水题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>某年元宵节大礼包</title>
    <link href="/2020/03/07/hzoi0001/"/>
    <url>/2020/03/07/hzoi0001/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>乐是做作业，给定正整数 N,M，要求计算Concatenate（1……N）mod M的值，其中Concatenate是指将1到N拼起来得到的数。如N=13，Concatenate=12345678910111213</p><span id="more"></span><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>一行两个整数，N，M</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>一个非负整数表示计算结果</p><h1 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h1><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">13 </span><span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>$n \leq 10^{18},m\leq 10^9$ </p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>第一眼看到这题：暴力模拟</p><p>然后看到数据表示无语，1e18啊，这拼起来得多大</p><p>不管了先弄一个模拟：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> s;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wei</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (x) &#123;<br>        s++;<br>        x /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;le.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;le.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        s = (s * <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-built_in">wei</span>(i)) + i),<br>        s = s % m;<br>    cout &lt;&lt; s;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个应该很好懂，就不解释了，30分</p><p>作为一个合格的OI选手，一定是要考虑正解的。</p><p>设ans[i]表示拼接到i位时的答案，我们很容易得到递推式：</p><p>ans[i]=(ans[i-1]*p+i)%mod; </p><p>其中p表示当前i的位数乘十，先不考虑mod，比如ans[4]=123*10+4；</p><p>于是这又是一个递推式问题，那么怎么办呢？暴力跑一遍?1e18的数据不TLE算我输</p><p>所以这个时候矩阵快速幂来了……</p><p>可以设一个矩阵A为</p><p>{ans[i]  i  1} 反正我是习惯开一维数组。。。。</p><p>然后另一个矩阵K为</p><p>{p　0　0}</p><p>{1　1　0}</p><p>{1　1　1}</p><p>这样A*K就能得到{ans[i]*p+i  i+1  1}即{ans[i+1]  i+1  1}</p><p>是不是很巧妙，所以不难看出上述A中的1的作用——与ans[i],凑出ans[i+1]和i+1.</p><p>接着考虑乘多少次方的问题，我们从i=0开始，如果n=4，那么显然要乘四次；</p><p>如果n=14呢？从0到9，一共要乘9次，然后再从10到14乘5次</p><p>接着多次进行迭代不难发现，我们可以用变量data拷贝n</p><p>如果n&gt;=p就乘9*p/10次，data减去乘的值</p><p>当n &lt; p 时说明不够乘了，所以直接乘以data次</p><p>最后跑快速幂就行了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br>ull n,mod,a[<span class="hljs-number">4</span>],c[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Mul</span><span class="hljs-params">()</span></span>&#123;<br>    ull cp[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">memset</span>(cp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(cp));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">3</span>;j++)&#123;<br>            cp[i]+=((a[j]%mod)*(c[j][i]%mod))%mod;<br>            <span class="hljs-comment">//乘之前一定要mod一下不然两个数乘积可能超出longlong</span><br>            cp[i]%=mod;<br>        &#125;  <br>    &#125;<br>    <span class="hljs-built_in">memcpy</span>(a,cp,<span class="hljs-built_in">sizeof</span>(cp));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Mulself</span><span class="hljs-params">()</span></span>&#123;<br>    ull cp[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">memset</span>(cp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(cp));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">3</span>;j++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">3</span>;k++)&#123;<br>                cp[i][j]+=((c[i][k]%mod)*(c[k][j]%mod))%mod;<br>                cp[i][j]%=mod;<br>            &#125;<br>    <span class="hljs-built_in">memcpy</span>(c,cp,<span class="hljs-built_in">sizeof</span>(cp));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%llu%llu&quot;</span>,&amp;n,&amp;mod);<br>    a[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;a[<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;a[<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;<br>    ull mx=n*<span class="hljs-number">10</span>,data=n;<br>    <span class="hljs-keyword">for</span>(ull p=<span class="hljs-number">10LL</span>;p&lt;=mx;p*=<span class="hljs-number">10LL</span>)&#123;<br>        c[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=p;c[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;c[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">0</span>;<br>        c[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;c[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;c[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">0</span>;<br>        c[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;c[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;c[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;<br>        ull x;<br>        <span class="hljs-keyword">if</span>(n&gt;=p)&#123;<br>            x=<span class="hljs-number">9LL</span>*p/<span class="hljs-number">10LL</span>;<br>            data-=x;<br>        &#125;<br>        <span class="hljs-keyword">else</span> x=data;<br>        <span class="hljs-keyword">while</span>(x)&#123;<br>            <span class="hljs-keyword">if</span>(x&amp;<span class="hljs-number">1</span>)<span class="hljs-built_in">Mul</span>();<br>            x&gt;&gt;=<span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">Mulself</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%llu\n&quot;</span>,a[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>早期水题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>矩阵快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU 3303 Harmony Forever</title>
    <link href="/2020/03/07/HDU3303/"/>
    <url>/2020/03/07/HDU3303/</url>
    
    <content type="html"><![CDATA[<h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>We believe that every inhabitant of this universe eventually will find a way to live together in harmony and peace; that trust, patience, kindness and loyalty will exist between every living being of this earth; people will find a way to appreciate and cooperate with each other instead of continuous bickering, arguing and fighting. Harmony – the stage of society so many people dream of and yet it seems so far away from now …</p><span id="more"></span><p>Fortunately, the method of unlocking the key to true Harmony is just discovered by a group of philosophers. It is recorded on a strange meteorite which has just hit the earth. You need to decipher the true meaning behind those seemingly random symbols … More precisely, you are to write a program which will support the following two kinds of operation on an initially empty set S :</p><ol><li>B X : Add number X to set S . The Kth command in the form of B X always happens at time K , and number X does not belong to set S before this operation.</li><li>A Y : Of all the numbers in set S currently, find the one which has the minimum remainder when divided by Y . In case a tie occurs, you should choose the one which appeared latest in the input. Report the time when this element is inserted.<br>It is said that if the answer can be given in the minimum possible time, true Harmony can be achieved by human races. You task is to write a program to help us.</li></ol><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>There are multiple test cases in the input file. Each test case starts with one integer T where 1&lt;=T&lt;=40000 . The following T lines each describe an operation, either in the form of “B X “ or “A Y “ where 1&lt;=X , Y&lt;=500000 .</p><p>T = 0 indicates the end of input file and should not be processed by your program.</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>Print the result of each test case in the format as indicated in the sample output. For every line in the form of “A Y “, you should output one number, the requested number, on a new line; output -1 if no such number can be found. Separate the results of two successive inputs with one single blank line.</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">5</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">A</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">10</span><br><span class="hljs-attribute">A</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">A</span> <span class="hljs-number">40</span><br><span class="hljs-attribute">2</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">A</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">0</span><br></code></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Case</span> <span class="hljs-number">1</span>:<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br><span class="hljs-keyword">Case</span> <span class="hljs-number">2</span>:<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p><del>让你拯救世界</del></p><p>给定一空集合，有两种操作，往集合里加数或者求出集合中的数在mod k意义下最小值是第几个加入的，相等的话输出最后加入的</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>不管怎么样先想一个暴力吧，单开一个数组记录往里边加的数，下边i表示加入时间，每次查询遍历一遍数组就行　</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> ss[<span class="hljs-number">5</span>];<br>    <span class="hljs-type">int</span> num,t,cas=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t))&#123;<br>        <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(t==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(cas)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %d:\n&quot;</span>,++cas);<br>        <span class="hljs-keyword">while</span>(t--)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d&quot;</span>,ss,&amp;num);<br>            <span class="hljs-keyword">if</span>(ss[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;B&#x27;</span>)<br>                a[++len]=num;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">bool</span> flag=<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> Min=num,ans;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>                    <span class="hljs-keyword">if</span>(a[i]%num&lt;=Min)&#123;<br>                        flag=<span class="hljs-number">0</span>;<br>                        Min=a[i]%num;<br>                        ans=i;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(flag)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>                <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>抱着试一试的心态交了上去，A了！！！没错它A了，但显然这不是正解，只是HDU数据水了，我自己手造了一组极限数据就跑了2s多，然后我又把它交到了POJ上，果然是TLE。</p><p>那肯定是要优化咯，怎么优化呢？涉及到mod的问题，如果要mod k在连续长度大于k的区间中，mod k一定会至少有两个数相等，所以我们可以考虑将50w分块，分为0-k-1，k-2k-1…………这样遍历每一块，每一块中最小的数mod k就有可能是答案，于是这个问题就成了，在区间内找到最小的已经出现过的数字，涉及到区间问题，很容易想到线段树和树状数组，但这个问题好像没有必要用线段树，树状数组足以。</p><p>开一棵50w的树状数组，每一个点记录到这个点一共出现了多少数字，接着就是找最小的已经出现过的数，那么不就又是暴力了吗？查找的方法除了暴力就只会二分，于是我们考虑二分查找，怎么二分呢？每次查找区间的时候，对该区间进行二分就行了，那你怎么知道是要向左分还是向右分？用树状数组很容易求得到区间左端点的点总数，取mid，如果到mid的点总数和到左端的点总数相等，说明l到mid之间没有数，改变左端点，如果有就改变右端点，更新最小值，继续二分直到l==r，树状数组的做法就是这样，线段树也大致差不多。</p><p>还有一个问题，如果k过小了，比如k就是1，那么我们就会将区间分成50w块，50w啊！而暴力最多只枚举4w，所以我们可以设置一个值，让k过大的时候直接用暴力。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> limit=<span class="hljs-number">1317</span>;<span class="hljs-comment">//这个数还可以换，让它别太小就行</span><br>                     <span class="hljs-comment">//不要问我为什么非用这个奇怪的数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> q[N+<span class="hljs-number">5</span>],tim[N+<span class="hljs-number">5</span>],a[N+<span class="hljs-number">5</span>],len,c[N+<span class="hljs-number">5</span>];<span class="hljs-comment">//多开5，防止RE</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> i&amp;(-i);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(x&lt;=N)&#123;<br>        c[x]++;<br>        x+=<span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Ins</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    tim[++len]=x;<br>    a[x]=len;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=limit;i++)&#123;<br>        <span class="hljs-keyword">if</span>(q[i]==<span class="hljs-number">0</span>)q[i]=len;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x%i&lt;=tim[q[i]]%i)q[i]=len;<span class="hljs-comment">//等于也要替换，因为优先输出后读入的</span><br>    &#125;<br>    <span class="hljs-built_in">Add</span>(x);<span class="hljs-comment">//加到树状数组里统计前缀和</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x)&#123;<br>        sum+=c[x];<br>        x-=<span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">low_find</span><span class="hljs-params">(<span class="hljs-type">int</span> ll,<span class="hljs-type">int</span> rr)</span></span>&#123;<br>    <span class="hljs-type">int</span> l,r,Min=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(ll==<span class="hljs-number">0</span>)l=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> l=ll;<br>    <span class="hljs-keyword">if</span>(rr&gt;N)r=N;<br>    <span class="hljs-keyword">else</span> r=rr;<br>    <span class="hljs-type">int</span> pre=<span class="hljs-built_in">front_sum</span>(l<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br>        <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> now=<span class="hljs-built_in">front_sum</span>(mid);<br>        <span class="hljs-keyword">if</span>(now&gt;pre)&#123;<span class="hljs-comment">//说明mid到l之间出现了值，向左找</span><br>            r=mid<span class="hljs-number">-1</span>;<br>            Min=mid;<br>        &#125;<span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<span class="hljs-comment">//没有值就向右找</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> Min;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<span class="hljs-keyword">return</span>;&#125;<br>    <span class="hljs-keyword">if</span>(x&lt;=limit)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,q[x]);<span class="hljs-keyword">return</span>;&#125;<br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=x<span class="hljs-number">-1</span>,ans=x<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;=N)&#123;<span class="hljs-comment">//判断左边界，判断右边界的话取值可能不完全</span><br>        <span class="hljs-type">int</span> now=<span class="hljs-built_in">low_find</span>(l,r);<br>        <span class="hljs-keyword">if</span>(now&amp;&amp;(now%x&lt;ans%x||now%x==ans%x&amp;&amp;a[now]&gt;a[ans]))&#123;<br>        <span class="hljs-comment">//等于和小于两种情况分开写，合在一起不行</span><br>            ans=now;<br>        &#125;<br>        l+=x;r+=x;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,a[ans]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span>    cas=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n))&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=N;i++)&#123;<br>            tim[i]=a[i]=c[i]=q[i]=<span class="hljs-number">0</span>;<br>        &#125;<br>        len=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(cas)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Case %d:\n&quot;</span>,++cas);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">char</span> ss[<span class="hljs-number">5</span>];<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d&quot;</span>,ss,&amp;k);<br>            <span class="hljs-keyword">if</span>(ss[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;A&#x27;</span>)<span class="hljs-built_in">calc</span>(k);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">Ins</span>(k);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>早期水题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>树状数组</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
